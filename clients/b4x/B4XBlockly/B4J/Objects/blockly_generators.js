/*
    Project:    HomeKit32
    File:       blockly_generators.js
    Brief:      Handle Blockly block actions.
				Async runtime generators for the standard & custom blocks.
				Generators return an async function (runtime) that runBlockQueue executes.
				- Uses evalInputAsync() to evaluate value inputs (handles built-ins like math_number / text)
				- Uses window.runtimeVariables for variables (avoid touching Blockly internals)
				- Expects a function sendCommandToB4JAsync(obj) to be available (fallback alerts if missing)

                Actions (JSON commands) are sent to B4J using sendCommandToB4JAsync().
                This file supports:
                  1) Custom blocks (LEDs, connect/disconnect, delay)
                  2) Standard blocks (log, comments)
                  3) Logic blocks (if, if-else, else-if, comparisons)
                  4) Loops (repeat, while)
                  5) Variables (get/set)
                  6) Start/Stop blocks
*/

// ======================================================================
// HELPER
// ======================================================================

// -----------------------------------------------------------------------------
// Helper: ensure sendCommandToB4JAsync exists (B4J may define window.b4j.JavaReceive or alert redirection)
if (typeof window.sendCommandToB4JAsync !== 'function') {
    window.sendCommandToB4JAsync = async function(obj) {
        // default: alert fallback (your B4J should intercept alerts)
        alert(JSON.stringify(obj));
    };
}

// runtime variable store (keeps async behavior isolated)
if (!window.runtimeVariables) window.runtimeVariables = {};

// Helper: evaluate a value input that may be generated by:
//  - our custom generators which return async functions
//  - built-in blocks where Generator returns code string (valueToCode)
// The helper returns a resolved JS value (boolean/number/string/object) or defaultValue.
async function evalInputAsync(block, inputName, defaultValue = null) {
    const inputBlock = block.getInputTargetBlock(inputName);
    if (!inputBlock) return defaultValue;

    const gen = Blockly.JavaScript[inputBlock.type];
    if (!gen) return defaultValue;

    let resultFn = gen(inputBlock);
    if (typeof resultFn === "function") {
        // Await the function if it's async
        let res = await resultFn();
        // If the result is itself a function (nested), keep resolving
        while (typeof res === "function") {
            res = await res();
        }
        return res;
    }
    return resultFn;
}

// Run queue helper (used by generated code)
window.runBlockQueue = async function(blockFns) {
    for (const fn of blockFns) {
        if (typeof fn === 'function') {
            await fn();
        }
    }
};

// ---------------------------
// GENERATORS (async runtime)
// ---------------------------

// ======================================================================
// CUSTOM BLOCKS
// ======================================================================

// --- Utility / flow ---
Blockly.JavaScript['start_block'] = block => async () => {
    // run all blocks attached after start in sequence
    const toRun = [];
    let cur = block.getNextBlock();
    while (cur) {
        const gen = Blockly.JavaScript[cur.type];
        if (gen) toRun.push(gen(cur));
        cur = cur.getNextBlock();
    }
    await sendCommandToB4JAsync({ command: "start" });
    await runBlockQueue(toRun);
};

Blockly.JavaScript['stop_block'] = block => async () => {
    await sendCommandToB4JAsync({ command: "stop" });
};

// --- Logging / text ---
Blockly.JavaScript['log_block'] = block => async () => {
    const inputBlock = block.getInputTargetBlock('TEXT');
    let msg = '';
    if (inputBlock) {
        const gen = Blockly.JavaScript[inputBlock.type];
        if (gen) {
            const resultFn = gen(inputBlock);
            if (typeof resultFn === "function") {
                msg = await resultFn();   // <-- important: await async result
            }
        }
    } else {
        msg = block.getFieldValue('TEXT') || '[log empty]';
    }

    // Send to B4J
    await sendCommandToB4JAsync({ command: "log", value: msg });
};

Blockly.JavaScript['text_literal'] = block => async () => {
    return block.getFieldValue('TEXT') || '';
};

// --- Devices / simple actions ---
Blockly.JavaScript['connect'] = block => async () => {
    await sendCommandToB4JAsync({ command: "connect" });
};
Blockly.JavaScript['disconnect'] = block => async () => {
    await sendCommandToB4JAsync({ command: "disconnect" });
};
Blockly.JavaScript['open_door'] = block => async () => {
    await sendCommandToB4JAsync({ command: "open_door" });
};
Blockly.JavaScript['yellow_led_on'] = block => async () => {
    await sendCommandToB4JAsync({ command: "yellow_led_on" });
};
Blockly.JavaScript['yellow_led_off'] = block => async () => {
    await sendCommandToB4JAsync({ command: "yellow_led_off" });
};
Blockly.JavaScript['yellow_led'] = block => async () => {
    const s = block.getFieldValue('STATE');
    await sendCommandToB4JAsync({ command: s === 'ON' ? 'yellow_led_on' : 'yellow_led_off' });
    // visual feedback (optional)
    block.setColour(s === 'ON' ? 90 : 60);
};

// DHT11 display block does not send commands; B4J updates the field values
Blockly.JavaScript['dht11_sensor'] = block => async () => {
    // no-op runtime; B4J updates fields via engine.executeScript("updateDeviceDHT11(temp,hum)")
    return;
};

// --- Delay ---
Blockly.JavaScript['delay'] = block => async () => {
    const ms = parseInt(block.getFieldValue('DELAY') || 1000);
    await sendCommandToB4JAsync({ command: "delay", value: ms });
    await new Promise(resolve => setTimeout(resolve, ms));
};

// ======================================================================
// STANDARD BLOCKS
// ======================================================================

// ---------------------------
// Logic control blocks (async runtime)
// Logic: boolean + compare (return booleans)
// - Each block returns true when this branch executed (useful for chaining else-if)
// ---------------------------
async function evalInputBool(block, inputName) {
    const r = await evalInputAsync(block, inputName, false);
    // ensure boolean
    return !!r;
}

Blockly.JavaScript['logic_boolean'] = function(block) {
    return async function() {
        return block.getFieldValue('BOOL') === 'TRUE';
    };
};

Blockly.JavaScript['logic_compare'] = function(block) {
    return async function() {
        const A = await evalInputAsync(block, 'A', 0);
        const B = await evalInputAsync(block, 'B', 0);
        const op = block.getFieldValue('OP');	// EQ, NEQ, LT, etc.

        switch (op) {
            case 'EQ':  return A == B;
            case 'NEQ': return A != B;
            case 'LT':  return A < B;
            case 'LTE': return A <= B;
            case 'GT':  return A > B;
            case 'GTE': return A >= B;
			default: return false;
        }
    };
};

Blockly.JavaScript['logic_operation'] = function(block) {
    return async function() {
        const A = await evalInputAsync(block, 'A', false);
        const B = await evalInputAsync(block, 'B', false);
        const op = block.getFieldValue('OP');

        if (op === 'AND') return A && B;
        return A || B;
    };
};

Blockly.JavaScript['logic_negate'] = function(block) {
    return async function() {
        const x = await evalInputAsync(block, 'BOOL', false);
        return !x;
    };
};

Blockly.JavaScript['logic_if'] = block => async () => {
    const cond = await evalInputAsync(block, 'COND', false);
    if (!cond) return false;

    const list = [];
    let c = block.getInputTargetBlock('DO');
    while (c) {
        const g = Blockly.JavaScript[c.type];
        if (g) list.push(g(c));
        c = c.getNextBlock();
    }
    await runBlockQueue(list);
    return true;
};

Blockly.JavaScript['logic_if_else'] = block => async () => {
    const cond = await evalInputAsync(block, 'COND', false);

    const list = [];
    let c;
    if (cond) {
        c = block.getInputTargetBlock('DO');
    } else {
        c = block.getInputTargetBlock('ELSE');
    }
    while (c) {
        const g = Blockly.JavaScript[c.type];
        if (g) list.push(g(c));
        c = c.getNextBlock();
    }
    await runBlockQueue(list);
};

Blockly.JavaScript['logic_else_if'] = block => async (prevExecuted = false) => {
    // If a previous branch executed, skip this block
    if (prevExecuted) return true;

    const cond = await evalInputAsync(block, 'COND', false);
    if (!cond) return false;

    // Execute the statements inside this else-if
    const list = [];
    let c = block.getInputTargetBlock('DO');
    while (c) {
        const g = Blockly.JavaScript[c.type];
        if (g) list.push(g(c));
        c = c.getNextBlock();
    }
    await runBlockQueue(list);

    // Return true to signal that this branch executed
    return true;
};

Blockly.JavaScript['math_number'] = block => async () => {
    return Number(block.getFieldValue('NUM'));
};

// ---------------------------
// Loops
// ---------------------------
Blockly.JavaScript['repeat_loop'] = block => async () => {
    const times = await evalInputAsync(block, 'TIMES', 1) || 0;
    const inner = [];
    let cur = block.getInputTargetBlock('DO');
    while (cur) {
        const gen = Blockly.JavaScript[cur.type];
        if (gen) inner.push(gen(cur));
        cur = cur.getNextBlock();
    }
    for (let i = 0; i < (Number(times) || 0); i++) {
        await runBlockQueue(inner);
    }
};

Blockly.JavaScript['while_loop'] = block => async () => {
    // basic safety limit
    let iter = 0, MAX_ITER = 1000;
    while (await evalInputBool(block, 'COND') && iter++ < MAX_ITER) {
        const inner = [];
        let cur = block.getInputTargetBlock('DO');
        while (cur) {
            const gen = Blockly.JavaScript[cur.type];
            if (gen) inner.push(gen(cur));
            cur = cur.getNextBlock();
        }
        await runBlockQueue(inner);
    }
};

// ---------------------------
// Variables (runtime store)
// ---------------------------
// Note: Blockly uses internal IDs for variables in some contexts.
//		 Need to use Blocklyâ€™s variable API to get the real variable name:

// ---------------------------
// Set variable
// ---------------------------
Blockly.JavaScript['variables_set'] = function(block) {
    const variable = Blockly.Variables.getVariable(block.workspace, block.getFieldValue('VAR'));
    const varName = variable ? variable.name : block.getFieldValue('VAR');
    return async function() {
        const val = await evalInputAsync(block, 'VALUE');
        window.workspaceVars[varName] = val;
        console.log(`Variable ${varName} set to`, val);
    };
};

// ---------------------------
// Get variable
// ---------------------------
Blockly.JavaScript['variables_get'] = function(block) {
    const variable = Blockly.Variables.getVariable(block.workspace, block.getFieldValue('VAR'));
    const varName = variable ? variable.name : block.getFieldValue('VAR');
    return async function() {
        const val = window.workspaceVars[varName];
        console.log(`Variable ${varName} retrieved:`, val);
        return val;
    };
};

// ---------------------------------------------
// Override Blockly.prompt for variable creation
// ---------------------------------------------

// Show variable dialog and return Promise
function showVariableDialog(defaultName = "") {
    return new Promise(resolve => {
        const dialog = document.getElementById('variableDialog');
        const input = document.getElementById('varNameInput');
        const btnOK = document.getElementById('btnVarOK');
        const btnCancel = document.getElementById('btnVarCancel');

        input.value = defaultName;
        dialog.style.display = 'block';
        input.focus();

        function cleanup() {
            dialog.style.display = 'none';
            btnOK.removeEventListener('click', okHandler);
            btnCancel.removeEventListener('click', cancelHandler);
        }

        function okHandler() { cleanup(); resolve(input.value.trim()); }
        function cancelHandler() { cleanup(); resolve(null); }

        btnOK.addEventListener('click', okHandler);
        btnCancel.addEventListener('click', cancelHandler);
    });
}

// Override Blockly.prompt
Blockly.prompt = async function(message, defaultValue, callback) {
    const name = await showVariableDialog(defaultValue);
    callback(name);
};
